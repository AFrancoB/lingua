// Generated by purs version 0.15.15
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_List from "../Data.List/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Parsing from "../Parsing/index.js";
import * as Parsing_Combinators_Array from "../Parsing.Combinators.Array/index.js";
import * as Parsing_Language from "../Parsing.Language/index.js";
import * as Parsing_String from "../Parsing.String/index.js";
import * as Parsing_Token from "../Parsing.Token/index.js";
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showInt);
var bind = /* #__PURE__ */ Control_Bind.bind(Parsing.bindParserT);
var pure = /* #__PURE__ */ Control_Applicative.pure(Parsing.applicativeParserT);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit)(Parsing.bindParserT);
var fromFoldable = /* #__PURE__ */ Data_List.fromFoldable(Data_Foldable.foldableArray);
var tokenParser = /* #__PURE__ */ Parsing_Token.makeTokenParser(Parsing_Language.haskellStyle);
var whitespace = /* #__PURE__ */ (function () {
    return tokenParser.whiteSpace;
})();
var stringLiteral = /* #__PURE__ */ (function () {
    return tokenParser.stringLiteral;
})();
var showParseError = function (v) {
    return show(v.value1.line) + (":" + (show(v.value1.column) + (" " + v.value0)));
};
var semi = /* #__PURE__ */ (function () {
    return tokenParser.semi;
})();
var reservedOp = /* #__PURE__ */ (function () {
    return tokenParser.reservedOp;
})();
var reserved = /* #__PURE__ */ (function () {
    return tokenParser.reserved;
})();
var parens = /* #__PURE__ */ (function () {
    return tokenParser.parens;
})();
var naturalOrFloat = /* #__PURE__ */ (function () {
    return tokenParser.naturalOrFloat;
})();
var natural = /* #__PURE__ */ (function () {
    return tokenParser.natural;
})();
var integer = /* #__PURE__ */ (function () {
    return tokenParser.integer;
})();
var identifier = /* #__PURE__ */ (function () {
    return tokenParser.identifier;
})();
var $$float = /* #__PURE__ */ (function () {
    return tokenParser["float"];
})();
var expression = /* #__PURE__ */ bind(/* #__PURE__ */ pure(1))(function () {
    return discard(whitespace)(function () {
        return bind(parens(identifier))(function (tx) {
            return pure(tx);
        });
    });
});
var parseExpressions = /* #__PURE__ */ bind(/* #__PURE__ */ pure(1))(function () {
    return bind(Parsing_Combinators_Array.many(expression))(function (xs) {
        return discard(Parsing_String.eof)(function () {
            return pure(fromFoldable(xs));
        });
    });
});
var parseAST = function (x) {
    return Parsing.runParser(x)(parseExpressions);
};
var parseProgram = function ($$eval) {
    return function (x) {
        var pr = parseAST(x);
        if (pr instanceof Data_Either.Left) {
            return new Data_Either.Left(showParseError(pr.value0));
        };
        if (pr instanceof Data_Either.Right) {
            return new Data_Either.Right(pr.value0);
        };
        throw new Error("Failed pattern match at Parser (line 26, column 5 - line 28, column 31): " + [ pr.constructor.name ]);
    };
};
var comma = /* #__PURE__ */ (function () {
    return tokenParser.comma;
})();
var colon = /* #__PURE__ */ (function () {
    return tokenParser.colon;
})();
var brackets = /* #__PURE__ */ (function () {
    return tokenParser.brackets;
})();
var braces = /* #__PURE__ */ (function () {
    return tokenParser.braces;
})();
export {
    parseProgram
};
